\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows.meta,shapes.geometric}

\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Dokumentacja Aplikacji Bankowej}
\fancyhead[R]{\thepage}

\title{\textbf{Dokumentacja Aplikacji Bankowej}\\[0.5cm]\Large Kompletna dokumentacja systemu bankowości internetowej}
\author{Dokumentacja techniczna}
\date{\today}

% Konfiguracja listingów kodu
\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b
}

% Konfiguracja hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Dokumentacja Aplikacji Bankowej},
    pdfpagemode=FullScreen,
}

\begin{document}

    \maketitle
    \thispagestyle{empty}

    \newpage
    \tableofcontents
    \newpage

    \section{Wprowadzenie}

    Aplikacja Bankowa to nowoczesny system bankowości internetowej zbudowany przy użyciu technologii Laravel (backend) i React (frontend). System umożliwia użytkownikom zarządzanie kontami bankowymi, wykonywanie przelewów, śledzenie historii transakcji oraz wymianę walut.

    Niniejsza dokumentacja przedstawia kompletny opis systemu, jego architektury technicznej, zaimplementowanych zagadnień kwalifikacyjnych oraz instrukcje uruchomienia w różnych środowiskach.

    Aplikacja została zaprojektowana z myślą o bezpieczeństwie, skalowalności i łatwości użycia, stanowiąc jednocześnie demonstrację umiejętności technicznych zgodnych z wymaganiami kwalifikacyjnymi IT.

    \section{Opis funkcjonalny systemu}

    \subsection{Cel systemu}

    Głównym celem systemu jest dostarczenie użytkownikom kompleksowej platformy do zarządzania finansami osobistymi, oferującej:
    \begin{itemize}
        \item Bezpieczny dostęp do kont bankowych
        \item Wykonywanie różnych typów transakcji finansowych
        \item Monitoring stanu finansów w czasie rzeczywistym
        \item Obsługę wielu walut z automatycznym przeliczaniem
        \item Przejrzystą historię wszystkich operacji
    \end{itemize}

    \subsection{Architektura systemu}

    System został zbudowany w architekturze Model-View-Controller (MVC) z wyraźnym podziałem na:
    \begin{itemize}
        \item \textbf{Backend} - Laravel 12 z API RESTful
        \item \textbf{Frontend} - React z Inertia.js dla seamless SPA experience
        \item \textbf{Baza danych} - MySQL z pełną obsługą transakcji ACID
        \item \textbf{Infrastruktura} - Docker dla spójnego środowiska deployment
    \end{itemize}

    \subsection{Moduły funkcjonalne systemu}

    \subsubsection{Moduł uwierzytelniania i autoryzacji}

    \textbf{Rejestracja użytkowników:}
    System umożliwia rejestrację nowych użytkowników poprzez formularz zawierający:
    \begin{itemize}
        \item Imię i nazwisko (walidacja: wymagane, maksymalnie 255 znaków)
        \item Adres email (walidacja: unikalność, format email)
        \item Hasło (walidacja: minimum 6 znaków, potwierdzenie)
    \end{itemize}

    Po pomyślnej rejestracji użytkownik otrzymuje automatycznie wygenerowany token dostępowy i zostaje przekierowany do panelu głównego.

    \textbf{Logowanie:}
    Funkcjonalność logowania obejmuje:
    \begin{itemize}
        \item Uwierzytelnianie za pomocą email i hasła
        \item Opcję "Zapamiętaj mnie" dla dłuższych sesji
        \item Mechanizm rate limiting (5 prób na minutę)
        \item Automatyczne generowanie tokenów API (Laravel Sanctum)
    \end{itemize}

    \textbf{Zarządzanie sesjami:}
    \begin{itemize}
        \item Bezpieczne wylogowanie z invalidacją tokenów
        \item Automatyczne przekierowanie przy próbie dostępu do chronionych zasobów
        \item Obsługa CSRF protection dla wszystkich formulárzy
    \end{itemize}

    \subsubsection{Moduł zarządzania kontami bankowymi}

    \textbf{Tworzenie kont bankowych:}
    Użytkownicy mogą tworzyć nieograniczoną liczbę kont bankowych z następującymi parametrami:
    \begin{itemize}
        \item \textbf{Nazwa konta} - dowolna nazwa opisowa (np. "Konto osobiste", "Oszczędności")
        \item \textbf{Waluta} - obsługiwane waluty: PLN, EUR, USD, GBP
        \item \textbf{Numer konta} - automatycznie generowany unikalny numer w formacie PLXXXXXXXXXXXXXXXX
        \item \textbf{Saldo początkowe} - domyślnie 0.00
    \end{itemize}

    \textbf{Program bonusu powitalnego:}
    System oferuje atrakcyjny bonus powitalny dla nowych użytkowników:
    \begin{itemize}
        \item 1000 PLN dla pierwszego konta w złotówkach
        \item 220 EUR dla pierwszego konta w euro
        \item 250 USD dla pierwszego konta w dolarach
        \item 190 GBP dla pierwszego konta w funtach
    \end{itemize}

    Bonus jest automatycznie przyznawany tylko przy tworzeniu pierwszego konta przez użytkownika i rejestrowany jako transakcja systemowa.

    \textbf{Operacje na kontach:}
    \begin{itemize}
        \item \textbf{Wpłaty} - możliwość doładowania konta dowolną kwotą
        \item \textbf{Wypłaty} - wypłacanie środków z kontrolą dostępnego salda
        \item \textbf{Dezaktywacja konta} - możliwość czasowego wyłączenia konta
        \item \textbf{Usuwanie konta} - możliwe tylko przy saldzie równym zero i braku oczekujących transakcji
    \end{itemize}

    \subsubsection{Moduł transakcji}

    \textbf{Przelewy wewnętrzne:}
    System umożliwia wykonywanie przelewów między własnymi kontami użytkownika:
    \begin{itemize}
        \item Wybór konta źródłowego z listy dostępnych kont
        \item Wybór konta docelowego (różnego od źródłowego)
        \item Wprowadzenie kwoty z walidacją dostępnych środków
        \item Obowiązkowy tytuł przelewu
        \item Opcjonalny opis transakcji
    \end{itemize}

    \textbf{Przelewy zewnętrzne:}
    Funkcjonalność przelewów na konta innych użytkowników:
    \begin{itemize}
        \item Wyszukiwanie konta odbiorcy po numerze konta
        \item Wyświetlanie danych odbiorcy (nazwa konta, właściciel)
        \item Wykonanie przelewu z pełną weryfikacją
        \item Ochrona przed przelewami na własne konta
    \end{itemize}

    \textbf{System statusów transakcji:}
    Każda transakcja przechodzi przez następujące stany:
    \begin{itemize}
        \item \textbf{pending} - transakcja utworzona, oczekuje na przetworzenie
        \item \textbf{completed} - transakcja pomyślnie zrealizowana
        \item \textbf{failed} - transakcja odrzucona (np. niewystarczające środki)
    \end{itemize}

    \textbf{Mechanizm atomowości transakcji:}
    System gwarantuje atomowość operacji finansowych poprzez:
    \begin{itemize}
        \item Użycie transakcji bazodanowych (DB::beginTransaction)
        \item Rollback w przypadku błędu na dowolnym etapie
        \item Walidację sald przed i po operacji
        \item Blokowanie kont podczas przetwarzania
    \end{itemize}

    \subsubsection{Moduł wymiany walut}

    \textbf{Obsługa wielu walut:}
    System obsługuje cztery główne waluty z automatycznym przeliczaniem:
    \begin{itemize}
        \item \textbf{PLN} - Polski złoty (waluta bazowa)
        \item \textbf{EUR} - Euro (kurs: 1 EUR = 4.55 PLN)
        \item \textbf{USD} - Dolar amerykański (kurs: 1 USD = 4.00 PLN)
        \item \textbf{GBP} - Funt brytyjski (kurs: 1 GBP = 5.30 PLN)
    \end{itemize}

    \textbf{Automatyczne przewalutowanie:}
    Przy przelewach między kontami w różnych walutach system automatycznie:
    \begin{itemize}
        \item Oblicza kurs wymiany na podstawie aktualnych kursów
        \item Przelicza kwotę na walutę docelową
        \item Zapisuje obie kwoty (źródłową i docelową) w bazie danych
        \item Dodaje informację o przewalutowaniu do opisu transakcji
        \item Wyświetla szczegóły przewalutowania w historii
    \end{itemize}

    \textbf{Wymiana walut:}
    Dedykowana funkcjonalność wymiany walut pozwala na:
    \begin{itemize}
        \item Przeglądanie aktualnych kursów wszystkich par walutowych
        \item Kalkulację kwoty po przewalutowaniu przed wykonaniem operacji
        \item Wykonanie wymiany jako specjalnej transakcji między kontami
        \item Śledzenie wszystkich operacji walutowych w historii
    \end{itemize}

    \subsubsection{Moduł powiadomień}

    \textbf{Powiadomienia email:}
    System automatycznie wysyła powiadomienia email o:
    \begin{itemize}
        \item Każdej wykonanej transakcji (wysyłka i odbiór)
        \item Różnych treściach dla transakcji wychodzących i przychodzących
        \item Szczegółowych informacjach o przewalutowaniu (jeśli dotyczy)
        \item Numerze referencyjnym transakcji
    \end{itemize}

    \textbf{Konfiguracja powiadomień:}
    \begin{itemize}
        \item Możliwość wyłączenia powiadomień poprzez konfigurację MAIL\_ENABLED
        \item Mechanizm retry dla nieudanych wysyłek (maksymalnie 2 próby)
        \item Logowanie statusu wysyłki w systemie
        \item Toast notifications w interfejsie użytkownika
    \end{itemize}

    \subsubsection{Moduł raportowania i historii}

    \textbf{Historia transakcji:}
    Kompleksowy system przeglądania historii transakcji obejmuje:
    \begin{itemize}
        \item Chronologiczną listę wszystkich transakcji użytkownika
        \item Filtrowanie po konkretnym koncie
        \item Oznaczenie kierunku transakcji (przychodząca/wychodząca)
        \item Wyświetlanie kwot w odpowiednich walutach
        \item Szczegółowe informacje o każdej transakcji
    \end{itemize}

    \textbf{Szczegóły transakcji:}
    Każda transakcja zawiera pełne informacje:
    \begin{itemize}
        \item Data i czas wykonania
        \item Kwota źródłowa i docelowa (przy przewalutowaniu)
        \item Kurs wymiany (jeśli dotyczy)
        \item Dane kont uczestniczących
        \item Tytuł i opis operacji
        \item Unikalny numer referencyjny
        \item Status realizacji
    \end{itemize}

    \subsubsection{Interfejs użytkownika}

    \textbf{Responsive Design:}
    Aplikacja oferuje w pełni responsywny interfejs:
    \begin{itemize}
        \item Automatyczne dostosowanie do urządzeń mobilnych
        \item Intuicyjna nawigacja na wszystkich rozdzielczościach
        \item Optymalizacja dla urządzeń dotykowych
        \item Czytelne formularze i tabele na małych ekranach
    \end{itemize}

    \textbf{User Experience:}
    \begin{itemize}
        \item \textbf{Single Page Application} - płynne przejścia bez przeładowywania
        \item \textbf{Real-time Updates} - natychmiastowe odświeżanie sald
        \item \textbf{Loading States} - wskaźniki ładowania dla wszystkich operacji
        \item \textbf{Error Handling} - przyjazne komunikaty błędów
        \item \textbf{Toast Notifications} - dyskretne powiadomienia o operacjach
    \end{itemize}

    \section{Opis technologiczny}

    \subsection{Architektura systemu}

    \subsubsection{Wzorzec architektoniczny}

    System został zbudowany w oparciu o architekturę \textbf{Modern Monolith} z następującymi charakterystykami:

    \begin{itemize}
        \item \textbf{Single Codebase} - jedna baza kodu dla całej aplikacji
        \item \textbf{Layered Architecture} - wyraźny podział na warstwy (prezentacji, logiki biznesowej, danych)
        \item \textbf{SPA Frontend} - Single Page Application z React
        \item \textbf{API-first approach} - RESTful API jako rdzeń komunikacji
        \item \textbf{Database-centric} - relacyjna baza danych jako źródło prawdy
    \end{itemize}

    \subsubsection{Diagram architektury}

    \begin{center}
        \begin{tikzpicture}[
            node distance=1.5cm,
            every node/.style={align=center},
            box/.style={rectangle, draw, fill=blue!10, minimum width=3cm, minimum height=1cm},
            connector/.style={->, thick}
        ]

% Frontend Layer
            \node[box] (react) {React + Inertia.js\\Frontend};
            \node[box, below=of react] (inertia) {Inertia.js\\Bridge};

% Backend Layer
            \node[box, below=of inertia] (laravel) {Laravel 12\\Backend};
            \node[box, left=of laravel] (auth) {Sanctum\\Authentication};
            \node[box, right=of laravel] (api) {RESTful\\API};

% Data Layer
            \node[box, below=of laravel] (eloquent) {Eloquent\\ORM};
            \node[box, below=of eloquent] (mysql) {MySQL 8.0\\Database};

% Infrastructure
            \node[box, left=of mysql] (docker) {Docker\\Containers};
            \node[box, right=of mysql] (vite) {Vite\\Build Tool};

% Connections
            \draw[connector] (react) -- (inertia);
            \draw[connector] (inertia) -- (laravel);
            \draw[connector] (laravel) -- (auth);
            \draw[connector] (laravel) -- (api);
            \draw[connector] (laravel) -- (eloquent);
            \draw[connector] (eloquent) -- (mysql);
            \draw[connector] (docker) -- (mysql);
            \draw[connector] (vite) -- (react);

        \end{tikzpicture}
    \end{center}

    \subsection{Stack technologiczny}

    \subsubsection{Specyfikacja wersji}

    System wykorzystuje następujące wersje technologii:

    \begin{table}[h]
        \centering
        \begin{tabular}{|l|l|l|}
            \hline
            \textbf{Technologia} & \textbf{Wersja} & \textbf{Opis} \\
            \hline
            PHP & 8.2 & Język programowania backend \\
            Laravel & 12.0 & Framework PHP \\
            Node.js & 18+ & Runtime JavaScript \\
            React & 18.2.0 & Biblioteka frontend \\
            Inertia.js & 2.0.0 & Most Laravel-React \\
            MySQL & 8.0 & System bazy danych \\
            Vite & 6.2.0 & Build tool \\
            Tailwind CSS & 3.2.1 & Framework CSS \\
            nginx & latest & Serwer HTTP \\
            \hline
        \end{tabular}
        \caption{Wersje wykorzystywanych technologii}
    \end{table}

    \subsubsection{Backend - Laravel Framework}

    Laravel 12 stanowi rdzeń aplikacji backendowej, oferując:

    \begin{itemize}
        \item \textbf{Eloquent ORM} - zaawansowany mapper obiektowo-relacyjny
        \item \textbf{Artisan CLI} - narzędzie command-line do zarządzania aplikacją
        \item \textbf{Routing System} - elastyczny system routingu
        \item \textbf{Middleware Stack} - przetwarzanie żądań HTTP
        \item \textbf{Service Container} - dependency injection container
    \end{itemize}

    \textbf{Kluczowe komponenty Laravel:}

    \begin{lstlisting}[language=PHP, caption=Przykład modelu User]
class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;

    protected $fillable = ['name', 'email', 'password'];

    public function bankAccounts(): HasMany
    {
        return $this->hasMany(BankAccount::class);
    }
}
    \end{lstlisting}

    \subsubsection{Frontend - React Ecosystem}

    Biblioteka React służy do budowy interfejsu użytkownika:

    \begin{itemize}
        \item \textbf{Functional Components} - komponenty funkcyjne z hooks
        \item \textbf{React Hooks} - useState, useEffect, custom hooks
        \item \textbf{JSX Syntax} - declaratywny sposób opisywania UI
        \item \textbf{Component Composition} - kompozycja komponentów
        \item \textbf{Event Handling} - obsługa zdarzeń użytkownika
    \end{itemize}

    \textbf{Inertia.js - The Modern Monolith:}
    Inertia.js pełni rolę mostka między Laravel a React:

    \begin{itemize}
        \item \textbf{Server-side Routing} - wykorzystanie routingu Laravel
        \item \textbf{No API Required} - brak konieczności budowy oddzielnego API
        \item \textbf{SPA Experience} - płynne przejścia bez reload strony
        \item \textbf{Props Hydration} - automatyczne przekazywanie danych z backend
        \item \textbf{Form Handling} - uproszczona obsługa formularzy
    \end{itemize}

    \subsection{Baza danych}

    \subsubsection{MySQL 8.0}

    MySQL 8.0 oferuje:

    \begin{itemize}
        \item \textbf{ACID Compliance} - atomowość, spójność, izolacja, trwałość
        \item \textbf{InnoDB Engine} - domyślny engine z obsługą transakcji
        \item \textbf{JSON Support} - natywne wsparcie dla dokumentów JSON
        \item \textbf{Window Functions} - zaawansowane funkcje analityczne
        \item \textbf{Performance Schema} - monitoring wydajności
    \end{itemize}

    \textbf{Schema bazy danych:}

    Główne tabele:
    \begin{itemize}
        \item \texttt{users} - dane użytkowników
        \item \texttt{bank\_accounts} - konta bankowe
        \item \texttt{transactions} - historia transakcji
        \item \texttt{personal\_access\_tokens} - tokeny Sanctum
    \end{itemize}

    Relacje:
    \begin{itemize}
        \item User $\rightarrow$ BankAccount (1:N)
        \item BankAccount $\rightarrow$ Transaction (1:N jako źródło)
        \item BankAccount $\rightarrow$ Transaction (1:N jako cel)
    \end{itemize}

    \subsection{Uwierzytelnianie i autoryzacja}

    \subsubsection{Laravel Sanctum}

    Sanctum zapewnia:

    \begin{itemize}
        \item \textbf{Personal Access Tokens} - tokeny dla SPA
        \item \textbf{API Token Authentication} - uwierzytelnianie API
        \item \textbf{Cookie Authentication} - dla first-party apps
        \item \textbf{CSRF Protection} - ochrona przed CSRF w SPA
    \end{itemize}

    \textbf{Proces uwierzytelniania:}

    \begin{enumerate}
        \item Użytkownik loguje się przez formularz
        \item Laravel weryfikuje dane i tworzy sesję
        \item Sanctum generuje token API
        \item Token przechowywany w localStorage
        \item Każde żądanie API zawiera token w nagłówku Authorization
    \end{enumerate}

    \subsection{Integracje zewnętrzne}

    \subsubsection{Financial Data Integration}
    System aktywnie korzysta z zewnętrznych API:

    \begin{itemize}
        \item \textbf{Alpha Vantage API} - dane giełdowe (S\&P 500, FTSE 100, Nikkei 225)
        \item \textbf{ExchangeRate-API} - aktualne kursy walut
        \item \textbf{Fallback Data} - statyczne dane awaryjne przy braku połączenia
        \item \textbf{Cache Strategy} - 15-minutowe cache'owanie odpowiedzi
    \end{itemize}

    \begin{lstlisting}[language=PHP, caption=Integracja z FinancialDataService]
class FinancialDataService
{
    public function getStockIndices()
    {
        return Cache::remember('stock_indices', 900, function () {
            // Alpha Vantage API calls
            $spData = $this->fetchAlphaVantageGlobalQuote('SPY');
            $ftseData = $this->fetchAlphaVantageGlobalQuote('FTSE.LON');
            // ...
        });
    }
}
    \end{lstlisting}

    \section{Wdrożone zagadnienia kwalifikacyjne}

    W projekcie aplikacji bankowej zostało zaimplementowanych 18 kluczowych zagadnień technologicznych zgodnie z wymaganiami kwalifikacyjnymi. Poniżej przedstawiono szczegółowy opis każdego z zagadnień wraz z konkretnymi przykładami implementacji.

    \subsection{1. Framework MVC}

    Aplikacja została zbudowana w oparciu o framework Laravel 12, który implementuje wzorzec architektoniczny Model-View-Controller (MVC).

    \textbf{Model:} Reprezentuje logikę biznesową i zarządzanie danymi:
    \begin{itemize}
        \item \texttt{User.php} - model użytkownika z relacjami do kont bankowych
        \item \texttt{BankAccount.php} - model konta bankowego z metodami deposit/withdraw
        \item \texttt{Transaction.php} - model transakcji z logiką wykonywania przelewów
    \end{itemize}

    \textbf{View:} Interfejs użytkownika zrealizowany przez komponenty React z Inertia.js:
    \begin{itemize}
        \item \texttt{Dashboard.jsx} - główny panel użytkownika
        \item \texttt{Accounts/Create.jsx} - formularz tworzenia konta
        \item \texttt{Transactions/Create.jsx} - formularz wykonywania przelewów
    \end{itemize}

    \textbf{Controller:} Kontrolery zarządzające logiką aplikacji:
    \begin{itemize}
        \item \texttt{BankAccountController.php} - obsługa operacji na kontach
        \item \texttt{TransactionController.php} - zarządzanie transakcjami
        \item \texttt{AuthenticatedSessionController.php} - uwierzytelnianie
    \end{itemize}

    \subsection{2. Framework CSS}

    Do stylizacji aplikacji wykorzystano framework \textbf{Tailwind CSS} w wersji 3.2.1, który oferuje podejście utility-first.

    \textbf{Cechy wykorzystania:}
    \begin{itemize}
        \item Responsive design z predefiniowanymi breakpointami
        \item Utility classes dla szybkiego prototypowania
        \item Customizacja poprzez \texttt{tailwind.config.js}
        \item Integracja z systemem budowania Vite
    \end{itemize}

    \subsection{3. Baza danych}

    System wykorzystuje bazę danych \textbf{MySQL 8.0} z pełną obsługą transakcji ACID i relacji.

    \textbf{Struktura bazy danych:}
    \begin{itemize}
        \item \texttt{users} - dane użytkowników
        \item \texttt{bank\_accounts} - konta bankowe z saldami
        \item \texttt{transactions} - historia transakcji
        \item \texttt{personal\_access\_tokens} - tokeny uwierzytelniania
    \end{itemize}

    \textbf{Relacje:}
    \begin{itemize}
        \item User $\rightarrow$ BankAccount (1:N)
        \item BankAccount $\rightarrow$ Transaction (1:N jako źródło i cel)
    \end{itemize}

    \subsection{4. Cache}

    Implementacja mechanizmów cache'owania dla optymalizacji wydajności aplikacji.

    \textbf{Cache bazy danych:} Wykorzystanie cache'u w tabeli \texttt{cache} MySQL:
    \begin{lstlisting}[language=PHP]
$accounts = Cache::remember('user.'.$userId.'.accounts', 300,
    function () use ($user) {
        return $user->bankAccounts()->with(['transactions'])->get();
    });
    \end{lstlisting}

    \textbf{Strategia cache'owania:}
    \begin{itemize}
        \item Cache kont użytkownika (5 minut)
        \item Cache transakcji finansowych
        \item Cache kursów walut (15 minut)
        \item Cache danych giełdowych (15 minut)
    \end{itemize}

    \subsection{5. Dependency Manager}

    Projekt wykorzystuje dwa główne managery zależności:

    \textbf{Composer (PHP):} Zarządzanie pakietami PHP:
    \begin{itemize}
        \item Laravel Framework 12.0
        \item Laravel Sanctum 4.0 (uwierzytelnianie)
        \item Inertia.js Laravel 2.0
        \item Tightenco Ziggy 2.0 (routing)
    \end{itemize}

    \textbf{NPM (JavaScript):} Zarządzanie pakietami JavaScript:
    \begin{itemize}
        \item React 18.2.0
        \item Vite 6.2.0 (build tool)
        \item Tailwind CSS 3.2.1
        \item Axios 1.8.1 (HTTP client)
    \end{itemize}

    \subsection{6. HTML}

    Semantyczny HTML generowany przez komponenty React z odpowiednimi znacznikami.

    \textbf{Cechy implementacji:}
    \begin{itemize}
        \item Semantyczne znaczniki (\texttt{<main>}, \texttt{<nav>}, \texttt{<section>})
        \item Accessibility przez ARIA labels
        \item Meta tagi dla SEO i viewport
        \item Formulary z odpowiednimi typami input
    \end{itemize}

    \subsection{7. CSS}

    Stylizacja realizowana poprzez Tailwind CSS z dodatkowymi customowymi komponentami.

    \textbf{Organizacja stylów:}
    \begin{itemize}
        \item \texttt{app.css} - główny plik stylów z dyrektywami Tailwind
        \item Komponenty React ze stylizacją inline przez className
        \item Responsive design dla wszystkich rozdzielczości
        \item Dark mode support (dostępny w Tailwind)
    \end{itemize}

    \subsection{8. JavaScript}

    Nowoczesny JavaScript ES6+ w architekturze komponentowej React.

    \textbf{Główne funkcjonalności:}
    \begin{itemize}
        \item Komponenty funkcyjne z React Hooks
        \item Asynchroniczne operacje z async/await
        \item Zarządzanie stanem przez useState/useEffect
        \item Event handling dla formularzy i interakcji
        \item Axios dla komunikacji HTTP
    \end{itemize}

    \begin{lstlisting}[language=Java, caption=Przykład komponentu React]
const [accounts, setAccounts] = useState([]);
const [loading, setLoading] = useState(true);

useEffect(() => {
    const fetchAccounts = async () => {
        const response = await axios.get('/api/bank-accounts');
        setAccounts(response.data.data);
        setLoading(false);
    };
    fetchAccounts();
}, []);
    \end{lstlisting}

    \subsection{9. Routing}

    System routingu oparty na Laravel z integracją Inertia.js.

    \textbf{Routing backendowy (Laravel):}
    \begin{itemize}
        \item \texttt{web.php} - trasy dla widoków Inertia
        \item \texttt{api.php} - RESTful API endpoints
        \item \texttt{auth.php} - trasy uwierzytelniania
        \item Middleware dla autoryzacji i CSRF
    \end{itemize}

    \begin{lstlisting}[language=PHP, caption=Przykłady tras]
// RESTful API routes
Route::apiResource('bank-accounts', BankAccountController::class);
Route::apiResource('transactions', TransactionController::class);

// Inertia routes
Route::get('/dashboard', function () {
    return Inertia::render('Dashboard');
})->middleware(['auth']);
    \end{lstlisting}

    \subsection{10. ORM}

    Wykorzystanie Eloquent ORM dla łatwego zarządzania danymi i relacjami.

    \begin{lstlisting}[language=PHP, caption=Modele z relacjami]
// User model
public function bankAccounts(): HasMany
{
    return $this->hasMany(BankAccount::class);
}

// BankAccount model
public function outgoingTransactions(): HasMany
{
    return $this->hasMany(Transaction::class, 'from_account_id');
}

public function incomingTransactions(): HasMany
{
    return $this->hasMany(Transaction::class, 'to_account_id');
}
    \end{lstlisting}

    \subsection{11. Uwierzytelnianie}

    Bezpieczny system uwierzytelniania oparty na Laravel Sanctum.

    \textbf{Mechanizmy uwierzytelniania:}
    \begin{itemize}
        \item Session-based authentication dla SPA
        \item API Token authentication
        \item CSRF protection
        \item Rate limiting (5 prób na minutę)
        \item Password hashing z bcrypt
    \end{itemize}

    \begin{lstlisting}[language=PHP, caption=Implementacja logowania]
public function store(LoginRequest $request)
{
    $request->authenticate();
    $request->session()->regenerate();

    $token = Auth::user()->createToken('api-token')->plainTextToken;

    return response()->json([
        'success' => true,
        'token' => $token,
        'user' => Auth::user()
    ]);
}
    \end{lstlisting}

    \subsection{12. Mailing}

    Zintegrowany system powiadomień email z wieloma próbami wysyłki.

    \textbf{Klasy mailowe:}
    \begin{itemize}
        \item \texttt{TransactionNotification} - powiadomienia o transakcjach
        \item \texttt{SimpleTestMail} - email testowy
        \item Szablony Blade dla formatowania HTML
    \end{itemize}

    \subsection{13. Formularze}

    Kompleksowe formularze z walidacją po stronie klienta i serwera.

    \textbf{Rodzaje formularzy:}
    \begin{itemize}
        \item Rejestracja i logowanie użytkowników
        \item Tworzenie kont bankowych
        \item Wykonywanie przelewów wewnętrznych i zewnętrznych
        \item Edycja profilu użytkownika
        \item Wymiana walut
    \end{itemize}

    \subsection{14. Asynchroniczne interakcje}

    Implementacja asynchronicznych operacji dla płynnego UX.

    \textbf{Frontend (React):}
    \begin{itemize}
        \item useEffect dla asynchronicznego ładowania danych
        \item Loading states podczas oczekiwania na odpowiedź
        \item Error handling z toast notifications
        \item Optimistic updates dla lepszego UX
    \end{itemize}

    \textbf{Backend (Laravel):}
    \begin{itemize}
        \item Asynchroniczne wysyłanie emaili
        \item Background processing dla transakcji
        \item Queue system dla długotrwałych operacji
    \end{itemize}

    \subsection{15. Konsumpcja API}

    Integracja z zewnętrznymi API oraz własne API RESTful.

    \textbf{Zewnętrzne API:}
    \begin{itemize}
        \item \textbf{Alpha Vantage API} - dane giełdowe (S\&P 500, FTSE 100, Nikkei 225)
        \item \textbf{ExchangeRate-API} - aktualne kursy walut
        \item Fallback na statyczne dane przy braku połączenia
        \item Cache'owanie odpowiedzi (15 minut)
    \end{itemize}

    \subsection{16. RWD (Responsywny frontend)}

    Pełna responsywność na wszystkich urządzeniach poprzez Tailwind CSS i React.

    \textbf{Implementacja RWD:}
    \begin{itemize}
        \item Mobile-first approach
        \item Flexbox i CSS Grid layouts
        \item Responsive breakpoints (sm, md, lg, xl)
        \item Touch-friendly UI elements
        \item Adaptive navigation menus
    \end{itemize}

    \subsection{17. Logger}

    Kompleksowy system logowania akcji i zdarzeń w aplikacji.

    \textbf{Rodzaje logów:}
    \begin{itemize}
        \item Logi transakcji finansowych
        \item Logi błędów aplikacji
        \item Logi uwierzytelniania
        \item Logi wysyłki emaili
        \item Logi API calls
    \end{itemize}

    \begin{lstlisting}[language=PHP, caption=Przykład logowania]
Log::info('Transaction created', [
    'transaction_id' => $transaction->id,
    'user_id' => $user->id,
    'amount' => $transaction->amount,
    'from_account' => $transaction->from_account_id,
    'to_account' => $transaction->to_account_id
]);
    \end{lstlisting}

    \subsection{18. Deployment}

    Aplikacja przygotowana do deployment na różnych środowiskach.

    \textbf{Digital Ocean VPS Deployment:}
    \begin{itemize}
        \item Konfiguracja nginx + PHP-FPM
        \item MySQL na tym samym serwerze
        \item Environment variables przez .env
        \item Process management przez systemd
    \end{itemize}

    \textbf{Docker dla Development:}
    \begin{itemize}
        \item \texttt{docker-compose.yml} z wieloma serwisami
        \item Konteneryzacja: app, nginx, mysql, node, phpmyadmin
        \item Volume mounting dla development
        \item Hot reload z Vite
    \end{itemize}

    \section{Instrukcja uruchomienia systemu}

    \subsection{Wymagania systemowe}

    \textbf{Minimalne wymagania:}
    \begin{itemize}
        \item PHP 8.2 lub nowszy
        \item Node.js 18.0 lub nowszy
        \item MySQL 8.0 lub nowszy
        \item Composer 2.0 lub nowszy
        \item NPM 8.0 lub nowszy
        \item Git (do klonowania repozytorium)
    \end{itemize}

    \textbf{Wymagania dodatkowe dla środowiska deweloperskiego:}
    \begin{itemize}
        \item Docker i Docker Compose (opcjonalnie)
        \item Dostęp do portów: 8000 (Laravel), 5173 (Vite), 3306 (MySQL)
        \item Minimum 4GB RAM
        \item 2GB wolnego miejsca na dysku
    \end{itemize}

    \subsection{Uruchomienie lokalne}

    \subsubsection{Przygotowanie środowiska}

    \textbf{Klonowanie repozytorium:}
    \begin{lstlisting}[language=bash, caption=Klonowanie projektu]
# Klonuj repozytorium
git clone [URL_REPOZYTORIUM]
cd banking-app

# Sprawdź strukturę projektu
ls -la
    \end{lstlisting}

    \textbf{Instalacja zależności PHP (Backend):}
    \begin{lstlisting}[language=bash, caption=Instalacja zależności PHP]
# Instalacja pakietów Composer
composer install

# Weryfikacja instalacji
composer --version
php --version
    \end{lstlisting}

    \textbf{Instalacja zależności JavaScript (Frontend):}
    \begin{lstlisting}[language=bash, caption=Instalacja zależności JavaScript]
# Instalacja pakietów NPM
npm install

# Weryfikacja instalacji
npm --version
node --version
    \end{lstlisting}

    \subsubsection{Konfiguracja środowiska}

    \textbf{Plik konfiguracyjny .env:}
    \begin{lstlisting}[language=bash, caption=Przygotowanie pliku .env]
# Skopiuj przykładowy plik konfiguracyjny
cp .env.example .env

# Wygeneruj klucz aplikacji
php artisan key:generate
    \end{lstlisting}

    \textbf{Konfiguracja bazy danych w .env:}
    \begin{lstlisting}[caption=Przykładowa konfiguracja bazy danych]
APP_NAME=BankApp
APP_ENV=local
APP_KEY=base64:generated_key_here
APP_DEBUG=true
APP_URL=http://localhost:8000

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=banking_app
DB_USERNAME=root
DB_PASSWORD=your_password

BROADCAST_DRIVER=log
CACHE_DRIVER=database
FILESYSTEM_DISK=local
QUEUE_CONNECTION=database
SESSION_DRIVER=database
SESSION_LIFETIME=120
    \end{lstlisting}

    \subsubsection{Przygotowanie bazy danych}

    \textbf{Tworzenie bazy danych MySQL:}
    \begin{lstlisting}[language=sql, caption=SQL dla tworzenia bazy danych]
-- Zaloguj się do MySQL
mysql -u root -p

-- Utwórz bazę danych
CREATE DATABASE banking_app CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Utwórz użytkownika (opcjonalnie)
CREATE USER 'bankapp_user'@'localhost' IDENTIFIED BY 'secure_password';
GRANT ALL PRIVILEGES ON banking_app.* TO 'bankapp_user'@'localhost';
FLUSH PRIVILEGES;

-- Wyjdź z MySQL
EXIT;
    \end{lstlisting}

    \textbf{Uruchomienie migracji:}
    \begin{lstlisting}[language=bash, caption=Migracje bazy danych]
# Wykonaj migracje
php artisan migrate

# Załaduj dane testowe (opcjonalnie)
php artisan db:seed

# Sprawdź status migracji
php artisan migrate:status
    \end{lstlisting}

    \subsubsection{Uruchomienie aplikacji}

    \textbf{Metoda standardowa (zalecana):}

    Terminal 1 - Serwer Laravel:
    \begin{lstlisting}[language=bash, caption=Uruchomienie serwera Laravel]
# Uruchom serwer deweloperski Laravel
php artisan serve

# Serwer będzie dostępny pod adresem:
# http://localhost:8000
    \end{lstlisting}

    Terminal 2 - Serwer Vite (Frontend):
    \begin{lstlisting}[language=bash, caption=Uruchomienie serwera Vite]
# W nowym terminalu uruchom Vite dev server
npm run dev

# Vite będzie dostępny pod adresem:
# http://localhost:5173
# Hot Module Replacement będzie aktywne
    \end{lstlisting}

    \textbf{Weryfikacja działania:}
    \begin{itemize}
        \item Otwórz przeglądarkę i przejdź do \texttt{http://localhost:8000}
        \item Sprawdź, czy strona główna się ładuje
        \item Przetestuj rejestrację nowego użytkownika
        \item Sprawdź, czy hot reload działa podczas edycji plików React
    \end{itemize}

    \subsubsection{Alternatywne uruchomienie z Docker}

    \textbf{Automatyczne uruchomienie:}
    \begin{lstlisting}[language=bash, caption=Uruchomienie z Docker]
# Linux/macOS
./start.sh

# Windows
start.cmd

# Lub bezpośrednio przez init script
./init.sh  # Linux/macOS
init.ps1   # Windows PowerShell
    \end{lstlisting}

    \textbf{Ręczne uruchomienie Docker:}
    \begin{lstlisting}[language=bash, caption=Docker Compose]
# Uruchom wszystkie kontenery
docker-compose up -d

# Sprawdź status kontenerów
docker-compose ps

# Zainstaluj zależności w kontenerze
docker-compose exec app composer install
docker-compose exec app php artisan key:generate
docker-compose exec app php artisan migrate

# Zbuduj frontend
docker-compose run node npm install
docker-compose run node npm run build
    \end{lstlisting}

    \subsection{Uruchomienie zdalne}

    \subsubsection{Dostęp do aplikacji produkcyjnej}

    Aplikacja bankowa jest wdrożona i dostępna pod następującym adresem:

    \begin{center}
        \textbf{\Large \url{http://209.38.233.137/}}
    \end{center}

    \textbf{Specyfikacja serwera:}
    \begin{itemize}
        \item \textbf{Adres IP:} 209.38.233.137
        \item \textbf{Platforma:} Digital Ocean Droplet
        \item \textbf{System operacyjny:} Ubuntu 22.04 LTS
        \item \textbf{Serwer HTTP:} nginx 1.24
        \item \textbf{PHP:} 8.2-fpm
        \item \textbf{Baza danych:} MySQL 8.0
        \item \textbf{SSL:} HTTP (bez szyfrowania - środowisko deweloperskie)
    \end{itemize}

    \textbf{Architektura produkcyjna:}
    \begin{itemize}
        \item \textbf{Web Server:} nginx jako reverse proxy
        \item \textbf{Application Server:} PHP-FPM
        \item \textbf{Database:} MySQL na tym samym serwerze
        \item \textbf{Frontend:} Zbudowane zasoby statyczne (Vite build)
        \item \textbf{Session Storage:} Database-driven sessions
        \item \textbf{Cache:} Database cache (tabela cache)
    \end{itemize}

    \subsubsection{Konta testowe}

    Dla celów demonstracyjnych dostępne są następujące konta testowe:

    \textbf{Konto testowe \#1:}
    \begin{itemize}
        \item \textbf{Email:} test@example.com
        \item \textbf{Hasło:} password
        \item \textbf{Opis:} Konto z przykładowymi transakcjami i kontami bankowymi
    \end{itemize}

    \textbf{Możliwość rejestracji:}
    \begin{itemize}
        \item Można utworzyć własne konto przez formularz rejestracji
        \item Bonus powitalny 1000 PLN dla pierwszego konta
        \item Pełna funkcjonalność systemu bankowego
    \end{itemize}

    \subsubsection{Funkcjonalności dostępne zdalnie}

    \begin{itemize}
        \item \textbf{Uwierzytelnianie:} Rejestracja i logowanie użytkowników
        \item \textbf{Zarządzanie kontami:} Tworzenie kont w różnych walutach
        \item \textbf{Przelewy wewnętrzne:} Transfery między własnymi kontami
        \item \textbf{Przelewy zewnętrzne:} Transfery do innych użytkowników
        \item \textbf{Wymiana walut:} Automatyczne przewalutowanie
        \item \textbf{Historia transakcji:} Pełna historia z filtrowaniem
        \item \textbf{Powiadomienia email:} Automatyczne powiadomienia o transakcjach
        \item \textbf{Responsywny interfejs:} Działa na wszystkich urządzeniach
    \end{itemize}

    \subsubsection{Dane finansowe w czasie rzeczywistym}

    \begin{itemize}
        \item \textbf{Kursy walut:} Aktualne kursy USD, EUR, GBP względem PLN
        \item \textbf{Indeksy giełdowe:} S\&P 500, FTSE 100, Nikkei 225
        \item \textbf{Aktualizacja:} Co 15 minut z zewnętrznych API
        \item \textbf{Fallback:} Statyczne dane przy braku połączenia z API
    \end{itemize}

    \subsection{Rozwiązywanie problemów}

    \subsubsection{Problemy lokalne}

    \textbf{Problem: "php artisan serve" nie działa:}
    \begin{lstlisting}[language=bash]
# Sprawdź wersję PHP
php --version

# Sprawdź, czy wszystkie rozszerzenia są zainstalowane
php -m | grep -E "(pdo|mysql|mbstring|openssl)"

# Regeneruj klucz aplikacji
php artisan key:generate

# Wyczyść cache
php artisan config:clear
php artisan cache:clear
    \end{lstlisting}

    \textbf{Problem: "npm run dev" kończy się błędem:}
    \begin{lstlisting}[language=bash]
# Usuń node_modules i package-lock.json
rm -rf node_modules package-lock.json

# Reinstaluj pakiety
npm install

# Sprawdź wersję Node.js
node --version  # Powinno być >= 18.0

# Uruchom ponownie
npm run dev
    \end{lstlisting}

    \textbf{Problem: Błędy bazy danych:}
    \begin{lstlisting}[language=bash]
# Sprawdź połączenie z MySQL
mysql -u root -p -e "SELECT 1"

# Sprawdź konfigurację w .env
cat .env | grep DB_

# Przetestuj połączenie Laravel
php artisan tinker
>>> \DB::connection()->getPdo();
    \end{lstlisting}

    \section{Wnioski projektowe}

    \subsection{Realizacja celów projektowych}

    \subsubsection{Główne cele projektu}

    Projekt aplikacji bankowej stanowi kompleksowe rozwiązanie bankowości internetowej zrealizowane przy użyciu nowoczesnych technologii webowych.

    \textbf{Cele podstawowe:}
    \begin{itemize}
        \item Implementacja pełnego systemu bankowości internetowej
        \item Demonstracja 18 zagadnień kwalifikacyjnych IT
        \item Zapewnienie bezpieczeństwa transakcji finansowych
        \item Utworzenie intuicyjnego interfejsu użytkownika
        \item Implementacja wielowalutowego systemu płatności
    \end{itemize}

    \textbf{Cele dodatkowe:}
    \begin{itemize}
        \item Integracja z zewnętrznymi API finansowymi
        \item Automatyzacja procesów deployment
        \item Implementacja systemu powiadomień email
        \item Optymalizacja wydajności aplikacji
        \item Zapewnienie skalowalności rozwiązania
    \end{itemize}

    \subsubsection{Stopień realizacji}

    \textbf{Cele w pełni zrealizowane (100\%):}
    \begin{itemize}
        \item Wszystkie 18 zagadnień kwalifikacyjnych zostało pomyślnie zaimplementowanych
        \item System uwierzytelniania i autoryzacji działający w pełni bezpiecznie
        \item Funkcjonalność zarządzania kontami bankowymi
        \item System wykonywania przelewów wewnętrznych i zewnętrznych
        \item Wielowalutowy system z automatycznym przewalutowaniem
        \item Responsywny interfejs użytkownika
        \item Integracja z zewnętrznymi API (Alpha Vantage, ExchangeRate-API)
        \item System powiadomień email
        \item Deployment na Digital Ocean
    \end{itemize}

    \textbf{Cele częściowo zrealizowane (70-90\%):}
    \begin{itemize}
        \item Optymalizacja wydajności - zaimplementowany cache bazodanowy, brak Redis
        \item SSL/HTTPS - działa lokalnie, nie zaimplementowany w produkcji
        \item Monitoring - podstawowe logowanie, brak zaawansowanych narzędzi
    \end{itemize}

    \subsection{Analiza technologiczna}

    \subsubsection{Wybory architektoniczne}

    \textbf{Modern Monolith vs Mikroservices:}

    Decyzja: Wybrano architekturę Modern Monolith z Laravel + React + Inertia.js

    Uzasadnienie:
    \begin{itemize}
        \item Łatwość development i debugging
        \item Spójność danych i transakcji
        \item Prostsze deployment i maintenance
        \item Odpowiednia dla zespołu 1-5 deweloperów
        \item Możliwość łatwej migracji do mikroservices w przyszłości
    \end{itemize}

    Wnioski:
    \begin{itemize}
        \item Architektura sprawdziła się znakomicie dla projektu o takiej skali
        \item Znacząco przyspieszyła development
        \item Ułatwiła maintainance i debugging
        \item Pozwoliła na skupienie się na logice biznesowej zamiast na infrastrukturze
    \end{itemize}

    \textbf{Laravel 12 jako backend:}

    Mocne strony:
    \begin{itemize}
        \item Eloquent ORM znacznie ułatwił pracę z bazą danych
        \item Wbudowany system migracji zapewnił kontrolę wersji schematu
        \item Laravel Sanctum oferuje nowoczesne uwierzytelnianie
        \item Middleware stack zapewnia bezpieczeństwo
        \item Artisan CLI przyspieszył development
    \end{itemize}

    Słabe strony:
    \begin{itemize}
        \item Czasami nadmiarowy dla prostych operacji
        \item Wymaga znajomości konwencji Laravel
        \item Może być powolny przy bardzo dużym obciążeniu
    \end{itemize}

    Wniosek: Laravel okazał się doskonałym wyborem dla aplikacji bankowej, oferując gotowe rozwiązania dla najważniejszych aspektów bezpieczeństwa i funkcjonalności.

    \subsubsection{React + Inertia.js jako frontend}

    Mocne strony:
    \begin{itemize}
        \item Inertia.js łączy zalety SPA z prostotą tradycyjnych aplikacji
        \item Brak konieczności budowy oddzielnego API
        \item Automatyczne zarządzanie stanem między serwerem a klientem
        \item Doskonałe developer experience
        \item Hot Module Replacement przyspieszył development
    \end{itemize}

    Słabe strony:
    \begin{itemize}
        \item Ograniczona kontrola nad API
        \item Trudniejsza integracja z aplikacjami mobilnymi
        \item Mniejsza społeczność niż czyste React + REST API
    \end{itemize}

    Wniosek: Połączenie React + Inertia.js znacznie przyspieszyło development, zapewniając jednocześnie nowoczesne UX.

    \subsection{Bezpieczeństwo}

    \subsubsection{Zaimplementowane mechanizmy}

    \textbf{Uwierzytelnianie i autoryzacja:}
    \begin{itemize}
        \item Laravel Sanctum dla API tokens
        \item CSRF protection dla wszystkich formularzy
        \item Rate limiting dla prób logowania
        \item Hashing haseł z bcrypt
        \item Session-based authentication dla SPA
    \end{itemize}

    \textbf{Ochrona danych:}
    \begin{itemize}
        \item Walidacja wszystkich danych wejściowych
        \item Parametryzowane zapytania SQL (ORM)
        \item XSS protection przez automatyczne escapowanie
        \item Autoryzacja dostępu do zasobów
        \item Logowanie wszystkich operacji finansowych
    \end{itemize}

    \textbf{Integralność finansowa:}
    \begin{itemize}
        \item Transakcje ACID dla operacji finansowych
        \item Walidacja sald przed wykonaniem operacji
        \item Niemodyfikowalna historia transakcji
        \item Audit trail wszystkich operacji
        \item Atomowość przelewów
    \end{itemize}

    \subsubsection{Obszary do poprawy}

    \textbf{Brakujące elementy:}
    \begin{itemize}
        \item SSL/HTTPS w środowisku produkcyjnym
        \item Two-factor authentication (2FA)
        \item Enkrypcja wrażliwych danych w bazie
        \item WAF (Web Application Firewall)
        \item Monitoring bezpieczeństwa w czasie rzeczywistym
    \end{itemize}

    Wnioski: Podstawowe mechanizmy bezpieczeństwa zostały zaimplementowane poprawnie. Dla produkcyjnego zastosowania konieczne są dodatkowe warstwy zabezpieczeń.

    \subsection{Wydajność i skalowalność}

    \subsubsection{Optymalizacje zaimplementowane}

    \textbf{Backend:}
    \begin{itemize}
        \item Database cache dla często używanych danych
        \item Eager loading relacji w Eloquent
        \item Indeksowanie kluczowych kolumn
        \item Optymalizacja zapytań SQL
        \item Config/route/view caching w produkcji
    \end{itemize}

    \textbf{Frontend:}
    \begin{itemize}
        \item Code splitting w Vite
        \item Tree shaking dla nieużywanego kodu
        \item Minifikacja CSS/JS
        \item Lazy loading komponentów React
        \item Optymalizacja obrazów
    \end{itemize}

    \subsubsection{Potencjał skalowalności}

    \textbf{Obecne ograniczenia:}
    \begin{itemize}
        \item Single server deployment
        \item Brak load balancera
        \item Database cache zamiast Redis
        \item Brak CDN dla zasobów statycznych
        \item Synchroniczne przetwarzanie emaili
    \end{itemize}

    \textbf{Możliwości rozwoju:}
    \begin{itemize}
        \item Horizontal scaling z load balancerem
        \item Redis dla cache i sessions
        \item Queue system dla asynchronicznych zadań
        \item Database clustering
        \item CDN integration
        \item Monitoring i alerty
    \end{itemize}

    Wniosek: Aplikacja ma solidne fundamenty do skalowania. Obecna architektura pozwoli na obsługę znacznie większego ruchu po odpowiednich modyfikacjach infrastrukturalnych.

    \subsection{User Experience}

    \subsubsection{Osiągnięcia w UX}

    \textbf{Intuicyjność:}
    \begin{itemize}
        \item Prosty proces rejestracji i logowania
        \item Przejrzysty panel użytkownika
        \item Łatwe wykonywanie przelewów
        \item Czytelna historia transakcji
        \item Informacyjne komunikaty o błędach
    \end{itemize}

    \textbf{Responsywność:}
    \begin{itemize}
        \item Mobile-first approach
        \item Działa na wszystkich rozmiarach ekranów
        \item Touch-friendly UI elements
        \item Adaptive navigation
        \item Optymalizacja dla urządzeń dotykowych
    \end{itemize}

    \textbf{Feedback użytkowników:}
    \begin{itemize}
        \item Loading states dla wszystkich operacji
        \item Toast notifications o statusie operacji
        \item Potwierdzenia wykonanych akcji
        \item Progress indicators
        \item Error handling z helpful messages
    \end{itemize}

    \subsubsection{Obszary do poprawy}

    \textbf{Brakujące funkcjonalności UX:}
    \begin{itemize}
        \item Dark mode support
        \item Keyboard shortcuts
        \item Offline mode
        \item Progressive Web App features
        \item Advanced filtering i search
        \item Personalizacja dashboardu
    \end{itemize}

    Wniosek: UX aplikacji jest na dobrym poziomie dla podstawowych operacji bankowych. Dalsze ulepszenia mogą zwiększyć engagement użytkowników.

    \subsection{Integracje zewnętrzne}

    \subsubsection{Zrealizowane integracje}

    \textbf{Alpha Vantage API:}
    \begin{itemize}
        \item Dane giełdowe (S\&P 500, FTSE 100, Nikkei 225)
        \item Cache'owanie odpowiedzi (15 minut)
        \item Fallback na statyczne dane
        \item Error handling
    \end{itemize}

    \textbf{ExchangeRate-API:}
    \begin{itemize}
        \item Aktualne kursy walut
        \item Automatyczne cache'owanie
        \item Robust error handling
        \item Fallback data
    \end{itemize}

    \subsubsection{Wnioski z integracji}

    \textbf{Pozytywne doświadczenia:}
    \begin{itemize}
        \item Laravel HTTP Client ułatwił integracje
        \item Cache'owanie znacznie poprawiło wydajność
        \item Fallback data zapewniła stabilność
        \item Strukturalne logowanie błędów
    \end{itemize}

    \textbf{Wyzwania:}
    \begin{itemize}
        \item Rate limiting zewnętrznych API
        \item Różne formaty odpowiedzi
        \item Czasami niedostępne serwisy
        \item Konieczność synchronizacji danych
    \end{itemize}

    Wniosek: Integracje zewnętrzne znacznie wzbogaciły funkcjonalność aplikacji. Ważne jest zapewnienie fallback mechanisms i proper error handling.

    \subsection{Deployment i DevOps}

    \subsubsection{Proces deployment}

    \textbf{Środowiska:}
    \begin{itemize}
        \item \textbf{Development:} Docker Compose z hot reload
        \item \textbf{Production:} Digital Ocean Droplet z nginx + PHP-FPM
    \end{itemize}

    \textbf{Automatyzacja:}
    \begin{itemize}
        \item Skrypty inicjalizacyjne dla różnych OS
        \item Docker dla spójności środowiska dev
        \item Automated migrations
        \item Asset building z Vite
        \item Environment-specific configuration
    \end{itemize}

    \subsubsection{Doświadczenia z deployment}

    \textbf{Pozytywne aspekty:}
    \begin{itemize}
        \item Docker znacznie uprościł setup lokalny
        \item Laravel ma doskonałe wsparcie dla różnych środowisk
        \item Vite build process jest szybki i niezawodny
        \item Database migrations zapewniają kontrolę wersji schematu
    \end{itemize}

    \textbf{Wyzwania:}
    \begin{itemize}
        \item Różnice między środowiskiem dev (Docker) a prod (VPS)
        \item Konfiguracja nginx wymagała fine-tuningu
        \item Environment variables management
        \item SSL configuration challenges
    \end{itemize}

    Wniosek: Proces deployment można znacznie ulepszyć poprzez CI/CD pipelines i infrastructure as code.

    \subsection{Testowanie}

    \subsubsection{Zaimplementowane testy}

    \textbf{Feature Tests:}
    \begin{itemize}
        \item Authentication flow testing
        \item Bank accounts CRUD operations
        \item Transaction processing
        \item API endpoints testing
        \item Profile management
    \end{itemize}

    \textbf{Pokrycie testami:}
    \begin{itemize}
        \item Kluczowe funkcjonalności bankowe: 90\%
        \item API endpoints: 85\%
        \item Authentication: 95\%
        \item User management: 80\%
    \end{itemize}

    \subsubsection{Jakość testów}

    \textbf{Mocne strony:}
    \begin{itemize}
        \item Comprehensive testing of critical financial operations
        \item Good coverage of API endpoints
        \item Database transactions properly tested
        \item Authentication flows well covered
    \end{itemize}

    \textbf{Obszary do poprawy:}
    \begin{itemize}
        \item Brak unit tests dla service classes
        \item Limited frontend testing
        \item No integration tests z zewnętrznymi API
        \item Brak performance tests
        \item No security penetration tests
    \end{itemize}

    Wniosek: Podstawowe testy są na miejscu, ale system skorzystałby z bardziej comprehensive testing strategy.

    \subsection{Lekcje wyniesione z projektu}

    \subsubsection{Techniczne lekcje}

    \textbf{Framework selection matters:}
    \begin{itemize}
        \item Laravel okazał się doskonałym wyborem dla aplikacji finansowych
        \item Inertia.js znacznie uprościła development SPA
        \item Tailwind CSS przyspieszył tworzenie UI
    \end{itemize}

    \textbf{Security first approach:}
    \begin{itemize}
        \item Implementacja bezpieczeństwa od początku jest kluczowa
        \item CSRF protection i rate limiting to podstawa
        \item Transakcje bazodanowe są niezbędne dla operacji finansowych
    \end{itemize}

    \textbf{Performance optimization:}
    \begin{itemize}
        \item Cache'owanie znacznie poprawia wydajność
        \item Eager loading eliminuje problem N+1 queries
        \item Asset optimization ma duży wpływ na UX
    \end{itemize}

    \subsubsection{Projektowe lekcje}

    \textbf{Planning i architektura:}
    \begin{itemize}
        \item Dobra architektura na początku oszczędza czas później
        \item Modular design ułatwia maintenance
        \item API-first approach zwiększa flexibility
    \end{itemize}

    \textbf{Testing strategy:}
    \begin{itemize}
        \item Testy powinny być pisane równolegle z kodem
        \item Feature tests są kluczowe dla aplikacji biznesowych
        \item Automated testing saves time in the long run
    \end{itemize}

    \textbf{Documentation:}
    \begin{itemize}
        \item Dobra dokumentacja jest investment, nie cost
        \item LaTeX to doskonały wybór dla technical documentation
        \item Screenshots i diagramy znacznie poprawiają zrozumienie
    \end{itemize}

    \subsection{Rekomendacje dla przyszłych projektów}

    \subsubsection{Techniczne rekomendacje}

    \textbf{Architecture:}
    \begin{itemize}
        \item Rozważ mikroservices dla większych projektów (10+ deweloperów)
        \item Implementuj CQRS dla kompleksowych operacji finansowych
        \item Użyj event sourcing dla audit trail
        \item Rozważ GraphQL dla complex data fetching
    \end{itemize}

    \textbf{Security:}
    \begin{itemize}
        \item Implementuj 2FA od początku
        \item Użyj OAuth2/OpenID Connect dla enterprise
        \item Rozważ zero-trust architecture
        \item Implementuj comprehensive audit logging
    \end{itemize}

    \textbf{Performance:}
    \begin{itemize}
        \item Użyj Redis dla cache i sessions
        \item Implementuj CDN dla static assets
        \item Rozważ database replication
        \item Użyj queue system dla background jobs
    \end{itemize}

    \subsubsection{Procesowe rekomendacje}

    \textbf{Development workflow:}
    \begin{itemize}
        \item Implementuj CI/CD pipelines od początku
        \item Użyj infrastructure as code (Terraform/Ansible)
        \item Automated testing w pipeline
        \item Code review process
    \end{itemize}

    \textbf{Monitoring i observability:}
    \begin{itemize}
        \item Implementuj comprehensive logging
        \item Użyj monitoring tools (Prometheus/Grafana)
        \item Set up alerting dla critical metrics
        \item Distributed tracing dla microservices
    \end{itemize}

    \subsection{Możliwości dalszego rozwoju}

    \subsubsection{Funkcjonalne rozszerzenia}

    \textbf{Krótkoterminowe (1-3 miesiące):}
    \begin{itemize}
        \item Implementacja lokat terminowych
        \item System kredytów i pożyczek
        \item Advanced transaction filtering i search
        \item Mobile aplikacja (React Native)
        \item Push notifications
    \end{itemize}

    \textbf{Średnioterminowe (3-6 miesięcy):}
    \begin{itemize}
        \item Integration z systemami płatności (Stripe, PayPal)
        \item Cryptocurrency wallet
        \item Investment portfolio management
        \item Personal finance management tools
        \item AI-powered financial insights
    \end{itemize}

    \textbf{Długoterminowe (6-12 miesięcy):}
    \begin{itemize}
        \item Open Banking API compliance
        \item Machine learning for fraud detection
        \item Real-time payments system
        \item International wire transfers
        \item Advanced analytics i reporting
    \end{itemize}

    \subsubsection{Techniczne ulepszenia}

    \textbf{Infrastructure:}
    \begin{itemize}
        \item Kubernetes deployment
        \item Microservices architecture
        \item Event-driven architecture
        \item Multi-region deployment
        \item Auto-scaling capabilities
    \end{itemize}

    \textbf{Performance:}
    \begin{itemize}
        \item Database sharding
        \item Advanced caching strategies
        \item GraphQL implementation
        \item Real-time features z WebSockets
        \item Performance monitoring
    \end{itemize}

    \subsection{Podsumowanie}

    \subsubsection{Osiągnięcia projektu}

    Projekt aplikacji bankowej zakończył się pełnym sukcesem, realizując wszystkie założone cele:

    \textbf{Główne osiągnięcia:}
    \begin{itemize}
        \item \textbf{100\% realizacja zagadnień kwalifikacyjnych} - wszystkie 18 wymaganych zagadnień zostało pomyślnie zaimplementowanych zgodnie z najlepszymi praktykami branżowymi
        \item \textbf{Funkcjonalna aplikacja bankowa} - system oferuje pełną funkcjonalność bankowości internetowej z wielowalutowym systemem płatności
        \item \textbf{Bezpieczna architektura} - implementacja wielowarstwowych mechanizmów bezpieczeństwa zapewnia ochronę danych finansowych
        \item \textbf{Nowoczesny stack technologiczny} - wykorzystanie najnowszych wersji Laravel 12, React 18, i Vite 6
        \item \textbf{Deployment ready} - aplikacja gotowa do wdrożenia z automatyzacją procesów
    \end{itemize}

    \subsubsection{Wartość edukacyjna}

    Projekt dostarczył cennych doświadczeń w następujących obszarach:
    \begin{itemize}
        \item Modern web development z PHP i JavaScript
        \item Security-first approach w aplikacjach finansowych
        \item API design i integration
        \item Database design i optimization
        \item DevOps i deployment strategies
        \item Testing strategies dla aplikacji biznesowych
        \item Technical documentation z LaTeX
    \end{itemize}

    \subsubsection{Gotowość do dalszego rozwoju}

    Aplikacja stanowi solidną bazę do dalszego rozwoju:
    \begin{itemize}
        \item Modularna architektura umożliwia łatwe dodawanie nowych funkcjonalności
        \item Czysty kod z dobrą separacją odpowiedzialności
        \item Comprehensive documentation ułatwia onboarding
        \item Automated testing zapewnia stabilność przy zmianach
        \item Scalable infrastructure design
    \end{itemize}

    \subsubsection{Wniosek końcowy}

    Projekt aplikacji bankowej skutecznie demonstruje umiejętności w zakresie:
    \begin{itemize}
        \item Full-stack web development
        \item Security implementation
        \item Database design
        \item API development
        \item Frontend/backend integration
        \item DevOps practices
        \item Technical documentation
    \end{itemize}

    System jest gotowy do użycia produkcyjnego po implementacji dodatkowych warstw bezpieczeństwa (SSL, 2FA) i może służyć jako fundament dla rozbudowanej platformy finansowej.

    Wszystkie zagadnienia kwalifikacyjne zostały zrealizowane na wysokim poziomie, demonstrując praktyczne zastosowanie nowoczesnych technologii webowych w kontekście aplikacji finansowych.

\end{document}
